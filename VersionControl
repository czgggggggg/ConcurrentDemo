Test1
    第一种创建线程的方法：直接使用Thread。重写run()方法，调用start()方法启动线程。
    thread.setName()给线程命名。
Test2
    第二种创建线程的方法：使用Runnable配合Thread。把任务封装到Runnable接口对象的run()方法中，然后把这个接口对象作为参数传递给Thread对象，并启动。
    Java8使用lambda简化代码。Runnable有一个@FunctionalInterface接口，意味着接口中只有一个抽象方法。
Test3
    第三种创建线程的方法：使用FutureTask配合Thread。 //Callable -> FutureTask -> Thread
    FutureTask类的构造方法可以传入一个Callable接口对象，Callable接口有一个call方法（有一个返回值还能抛出异常）。
    重写Callable匿名接口对象的call()方法，作为参数传入FutureTask对象。
    再把FutureTask对象作为参数传入Thread对象。
    Future对象的get()方法会阻塞一直等待线程结束，并获取Callable的call()方法的返回值。
Test4_MultiThread
    多个线程同时运行的例子
Test5_Frames1
    栈和栈帧
    通过IDEA的调试器观察。//JVM的结构：栈（包含栈帧）、堆（存放对象）、方法区
Test6_Frames2
    JVM栈和线程
    JVM可以有多个栈，每个线程都有一个对应的栈，且每个栈只有一个活动栈帧，对应线程正在执行的那个方法。
    不同线程的栈之间是相互独立不干扰的。可以通过IDEA的调试器观察（注意断点类型不要选择默认的ALL，而是线程类型）。
Test7_start_vs_run
    start()方法和run()方法的比较
    线程直接调用run()方法，并没有启动新的线程，而是由主方法的线程在执行。本质上还是单线程，依然是同步而非异步。
    start()方法才会启动一个新的线程，让新的线程进入就绪状态。
Test8_status
    getState()获取线程的状态。
    同一个线程多次调用start()方法会报java.lang.IllegalThreadStateException异常。
Test9_sleep
    线程t1调用sleep()方法。该线程在线程外部调用getState()方法查看线程状态。
Test10_interrupt
    线程t1调用sleep()方法。该线程在线程外部调用interrupt()方法打断正在睡眠的线程t1，此时sleep()方法会抛出InterruptedException异常，t1被唤醒。
    睡眠结束后，线程未必立刻得到执行。
    建议用TimeUnit的sleep替代Thread的sleep。例如，用TimeUnit.SECONDS.sleep(2);取代Thread.sleep(2000);
Test11_yield
    yield和优先级的例子不大好设计，因为如果没有其他线程和当前线程竞争CPU资源，那么当前线程还是会处于运行状态。
    Thread.yield()会让线程从运行状态转换为就绪状态，然后调度执行其他线程，而sleep()是让线程从运行状态转换为阻塞状态。
    线程优先级会提示（hint）调度器优先调度该线程，但它仅仅只是一个提示，调度器可以忽略它。
    Thread中提供了1~10 共10个优先级，最小优先级MIN_PRIORITY = 1，默认优先级NORM_PRIORITY = 5，最大优先级MAX_PRIORITY = 10。
    如果CPU比较忙，优先级高的线程会获得更多的时间片，如果CPU比较空闲，优先级几乎没有作用。
    案例中无论是让线程1调用yield()，还是给线程2更高的优先级，都会让线程2计算更多次count++。
    最终还是由操作系统的调度器来给线程分配CPU时间片，yield()和优先级高低本质上还是控制不了的。
Test12
    sleep()防止CPU占用100%的一个案例。//这个案例要在单核CPU下才可以观察的到，可以用虚拟机，并给虚拟机分配一个核心。
    在没有利用CPU来计算时，不要让while(true)空转浪费CPU资源，这个时候可以使用yield()或sleep()将CPU使用权让给其他线程。
Test13_join1
    join的一个应用案例。
    在当前线程中要等待t1线程结束，t1.join()。
    //需要等待结果返回，才能继续运行的时同步；不需要等待结果返回，就能继续执行的是异步。
Test14_join2
    等待多个线程的一个案例。
Test15_join3
    有时效的join
    等待时间不够，就不等待被等待线程执行完，继续往下执行。
    等待时间超过被等待线程的运行时长，那么当被等待线程运行结束时，就立马结束等待。
Test16_interrupt_block
    打断阻塞
    interrupt()打断sleep、wait、join的线程，被打断的线程都会进入阻塞状态。
    以sleep为例，会抛出异常、情况打断状态，isInterrupted()的返回值为false，而打断正常运行的线程，isInterrupted()的返回值为true。
Test17_interrupt_normal
    打断正常的例子
    打断正常运行的线程，不会清空打断状态。
Test18
    两阶段终止模式的实现
    原理上理解的还可以，实现的理解不充分。
    //另外，注意一下，isInterrupted()和interrupted()方法都会返回打断标记，但是，interrupted()会清除打断标记，而isInterrupted()不会。
Test19_interrupt_park
    打断park
    LockSupport.park();
    没有t1.interrupt()则t1一直停止，t1.interrupt()让park解除，且打断标记为true，可以视为正常打断。
    此时线程t1再遇到LockSupport.park();就不会再停下来了，也就是打断标记为true的情况下，park会失效
    解决办法是不用isInterrupted()返回打断标记，而用Thread.interrupted()返回，因为Thread.interrupted()会清除线程t1的打断标记。
Test20
    不推荐的方法
    还有一些不推荐的方法，这些方法已经过时，容易破坏同步代码块，造成线程死锁。//stop()、suspend()、resume()

