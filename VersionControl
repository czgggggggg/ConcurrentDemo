Test1
    第一种创建线程的方法：直接使用Thread。重写run()方法，调用start()方法启动线程。
    thread.setName()给线程命名。
Test2
    第二种创建线程的方法：使用Runnable配合Thread。把任务封装到Runnable接口对象的run()方法中，然后把这个接口对象作为参数传递给Thread对象，并启动。
    Java8使用lambda简化代码。Runnable有一个@FunctionalInterface接口，意味着接口中只有一个抽象方法。
Test3
    第三种创建线程的方法：使用FutureTask配合Thread。 //Callable -> FutureTask -> Thread
    FutureTask类的构造方法可以传入一个Callable接口对象，Callable接口有一个call方法（有一个返回值还能抛出异常）。
    重写Callable匿名接口对象的call()方法，作为参数传入FutureTask对象。
    再把FutureTask对象作为参数传入Thread对象。
    Future对象的get()方法会阻塞一直等待线程结束，并获取Callable的call()方法的返回值。
Test4_MultiThread
    多个线程同时运行的例子
Test5_Frames1
    栈和栈帧
    通过IDEA的调试器观察。//JVM的结构：栈（包含栈帧）、堆（存放对象）、方法区
Test6_Frames2
    JVM栈和线程
    JVM可以有多个栈，每个线程都有一个对应的栈，且每个栈只有一个活动栈帧，对应线程正在执行的那个方法。
    不同线程的栈之间是相互独立不干扰的。可以通过IDEA的调试器观察（注意断点类型不要选择默认的ALL，而是线程类型）。
Test7_start_vs_run
    start()方法和run()方法的比较
    直接调用run()方法，并没有启动新的线程，而是由主方法的线程在执行。本质上还是单线程，依然是同步而非异步。
    start()方法才会启动一个新的线程，让新的线程进入就绪状态。




